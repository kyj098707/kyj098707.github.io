---
layout: post
title: Performance Issues
---
#### 요즘 저희는 컴퓨터가 정말 발달한 세대에 살고 있습니다.
#### 혹시 10년전 ~ 15년 전 슈퍼 컴퓨터가 오늘 날의 노트북의 성능이라는걸 알고 계신가요?!
#### 저희는 이런 급격한 컴퓨터의 성능의 향상의 속에서 살고 있다고 할 수 있습니다.
#### 그러면 어떤 것들이 컴퓨터의 성능의 향상을 일으키는지 컴퓨터를 배우시는 분들이라면 알아야겠죠?
#### 오늘은 이런 부분들을 알아보려고 합니다. 같이 한 번 가보시죠!
---
## 1> 고성능화를 발생시킨 기법들
##### 1) Pipelining : 한 번에 하나의 명렁어가 실행되는 것이 아니라, 하나의 명령어가 실행되는 도중에 다른 명렁어가 실행되는 기법, 끊임없이 명렁어가 실행되는 것이다.
##### 2) Branch predicition : 다음 실행 될 브렌치가 정확히 어딘지 알기전에 미리추측하는 CPU기술.
##### 3) Superscalar execution : 정수연산을 스칼라 연산이라고 하는데 SUPER가 붙어 많은 스칼라연산을 하는 연산기가 많은 것을 의미한다. 
##### 4) Data flow analysis : 명령어들의 의존성을 분석하여 어느 순서대로 하는 것이 최적일지를 알아내는 기법.
##### 5) Speculative execution : 정확한 정보가 아닌 추측에 기반을 정보, 어떤 명령어가 실행이 될 때 다음 번에 어떤 것이 실행 될 것이다. 패치해서 가져오는 것
---
#### 프로세스를 설계하는데 있어서 가장 신경써야 하는 부분이 있다.
#### 바로 프로세스는 매우 빠른데, 이에 비해 메모리는 매우 느리다는 점이다.
#### 이렇게 되면 전체적인 성능은 느린 것(메모리)에 의존하게되며 실행 밸런스를 맞춰야 성능은 좋아지게 된다.
## 2> 성능을 높이는 법
##### 1) 먼저 메모리는 한 번에 읽을 수 있는 양(wider)
##### > 얼만큼 많은 양을 가질 수 있는가(deeper)가 성능에 좋다
##### 2) 시도때도 없이 메모리에 접근을 줄일수록 성능이 좋아진다 >> 좋은 캐쉬 사용
##### 3) 인터페이스의 속도를 높이는 것도 전체적인 속도 불균형 감소에 도움이 된다.
##### 이것 이외에도 성능을 향상시키는 것으로
##### -하드웨어의 속도를 높이는 것
##### -캐쉬를 사용하는 방식
##### -shrinking logic gate size 방식
##### 병렬형 컴퓨터의 사용이 있다.
---
##### 클락속도를 계속 높이고 로직을 키웠을 때 성능은 좋아지지만 큰 문제가 하나 발생하게 된다.
## 3> 성능을 높였을 때의 문제점
##### - 열이 많이 발생하게 된다. >> 쿨러기가 점점 커지고 있는 상태이다.
##### - Power = C * V^2 * F
##### - RC DELAY가 많이 생길 수 밖에없다.
##### - 저항과 커페시티가 높을 수록 전류가 느려지고, 이에 따라 열이 생기며 전류가 흐르는 양이 제한이 된다.
#### 최근 트렌드를 한 번 살펴보면
##### - 트렌지스터의 성능은 계속해서 높아지고
##### - 주파수와 파워는 일정하게 설계되고 있다.
##### 두 개가 같이 커져야 마땅하지만 어떤 방법으로 이를 해결했을까?
##### >> 바로 코어의 개수를 높여서 제어하고 있다(페어럴리즘, 병렬화)
##### Multicore : 클락속도를 높여 성능을 높이는 것이 아니라 여러 코어를 사용하여 성능을 높이는 것
##### >> 소프트웨어도 병렬을 시켜야 이것이 수월해진다.
---
## 3> 암달의 법칙과 리틀스의 법칙
### 1) 암달의 법칙
##### - 병렬형 컴퓨터와 관련해서 암달이라는 사람이 만든 법칙 이있다.
##### - 우리가 소프트웨어 코드 중에서 f만큼 병렬 처리가 가능하고, 1-f 정도를 병렬 처리가 안된다고 했을 때
##### - SpeedUp = 싱글시간/병렬시간 = 
##### - (T(1-f)+Tf) / (T(1-f)+Tf/N)이고 결국
##### - 1/((1-f)+f/N)이 되고 N이 커질 수록 값이 줄어들고  결국 어느 한 시간에 수렴하게 된다.
### 2) 리틀스 법칙
##### 어떤 시스템이 정상상태에 도달했을 때 서비스 시간이 얼만큼 되는지 설명해주는 법칙
##### L = ㅅ* W
##### >> 평균 도달 비율 * 한 개당 평균적으로 얼마나 걸리는지
##### >> 시스템에 기다리고 있는 아이템의 개수
---
## 4> 평균
#### 우리보고 흔히 값들의 평균을 구하라고 하면 구하는 값들을 다 더하고 개수 만큼 나눌 것이다.
##### 이를 보통 우리는 산술평균이라고 부르고
##### 컴퓨터 구조에서 성능의 벨런싱이 얼마나 잘되어있나를 보기위해서는 조화평균을 봐야하며 이 값은 값들이 크고 값들간의 차이가 작을 때 큰 값을 가지게 된다.
---
## 5> 벤치마커의 법칙
##### 프로세서가 복잡해질수록 이론들이 통하지 않는 경우가 많다. 이론말고 실제 프로그램을 돌리고 이를 통해 사양을 알아보는 것을 벤치마커의 법칙으로 불리며 여기서 가장 유명한것이 SPEC이다. 
##### SPEC : 여러 프로그램을 돌려서 실제 값이 먼지 알아 보는 것
##### 벤치마킹 : 시스템을 돌리 는 것 ( 여러 프로그램을 돌려서 프로그램 사양을 알아보는 것)